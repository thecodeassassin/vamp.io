<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Why use vamps on Vamp</title>
    <link>why-use-vamp/index.xml</link>
    <description>Recent content in Why use vamps on Vamp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the Apache 2 license</copyright>
    <lastBuildDate>Tue, 13 Sep 2016 09:00:00 +0000</lastBuildDate>
    <atom:link href="why-use-vamp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Canary test and release a responsive frontend</title>
      <link>/why-use-vamp/use-cases/create-responsive-website/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/create-responsive-website/</guid>
      <description>&lt;p&gt;&lt;em&gt;“We need to upgrade our website frontend to make it responsive”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Developing a responsive web frontend is often a major undertaking, requiring a large investment of hours and extensive testing. Until you go live, it&amp;rsquo;s difficult to predict how the upgrade will be received by users - will it actually improve important metrics, will it work on all browser, devices and resolutions, etc.?&lt;/p&gt;

&lt;p&gt;But why develop this new responsive frontend in one go, having to go for the dreaded and risky big-bang release? Using Vamp you can apply a canary release to introduce the new frontend to a selected cohort of users, browsers and/or devices. This would require a minimal investment of development and delivering real usage data:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Start small:&lt;/strong&gt; Build the new frontend for only one specific browser/resolution first to measure effectiveness. Vamp can deploy the new responsive frontend and route a percentage of supported users with this specific browser and screen-resolution there. All other users will continue to see the old version of your website.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimise:&lt;/strong&gt; With the new responsive frontend in the hands of real users with this specific browser/resolution, you can measure actual data and optimise accordingly without negatively affecting the majority of your users.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scale up:&lt;/strong&gt; Once you are satisified with the performance of the new frontend, you can use Vamp to scale up the release, developing and canary releasing one browser/resolution at a time. Of course other cohort combinations are also possible, Vamp is open and supports all HAProxy ACL rules.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about using Vamp to &lt;a href=&#34;./why-use-vamp/use-cases/resolve-incompatibilities-after-upgrade/&#34;&gt;resolve client-side incompatibilities after an upgrade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Feature list</title>
      <link>/why-use-vamp/feature-list/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/feature-list/</guid>
      <description>&lt;p&gt;Vamp 0.9.1 includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Container-scheduler agnostic API&lt;/li&gt;
&lt;li&gt;Percentage and condition based programmable routing&lt;/li&gt;
&lt;li&gt;YAML based configuration blueprints with support for dependencies, clusters and environment variables&lt;/li&gt;
&lt;li&gt;Graphical UI and dashboard&lt;/li&gt;
&lt;li&gt;Integrated javascript-based workflow system&lt;/li&gt;
&lt;li&gt;Metric-driven autoscaling, canary releasing and other optimisation and automation patterns&lt;/li&gt;
&lt;li&gt;Automatic loadbalancing for autoscaled services&lt;/li&gt;
&lt;li&gt;API gateway routing features like conditional rewrites&lt;/li&gt;
&lt;li&gt;CLI for integration with common CI/CD pipelines&lt;/li&gt;
&lt;li&gt;Open source (Apache 2.0)&lt;/li&gt;
&lt;li&gt;Event API and server-side events (SSE) stream&lt;/li&gt;
&lt;li&gt;Multi-level metric aggregation&lt;/li&gt;
&lt;li&gt;Port-based, virtual host names or external service (consul etc) based service discovery support&lt;/li&gt;
&lt;li&gt;Lightweight design to run in high-available mission-critical architectures&lt;/li&gt;
&lt;li&gt;Integrates with ELK stack (Elastic Search, Logstash, Kibana) for custom Kibana dashboards&lt;/li&gt;
&lt;li&gt;Vamp Runner provides automated integration and workflows testing&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/installation/hello-world/&#34;&gt;Try Vamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./why-use-vamp/use-cases/&#34;&gt;Use cases&lt;/a&gt;: Vamp solutions to practical problems&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;What Vamp offers compared to other tools and services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components/&#34;&gt;How Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Frameworks and tools</title>
      <link>/why-use-vamp/vamp-compared-to/frameworks-and-tools/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/vamp-compared-to/frameworks-and-tools/</guid>
      <description>

&lt;h2 id=&#34;vamp-compared-to-ci-cd-tools&#34;&gt;Vamp compared to CI/CD tools&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Spinnaker, Jenkins, Wercker, Travis, Bamboo&lt;/em&gt;&lt;br /&gt;
Vamp closes the loop between the development and operations elements of a CI/CD pipeline by enabling the controlled introduction of a deployable into production (canary-test and canary-release) and feeding back runtime technical and business metrics to power automated optimisation workflows (such as autoscalers). Vamp integrates with CI/CD tools like Travis, Jenkins or Wercker to canary-release and scale the built deployables they provide. The initial deployment setup is defined in a YAML blueprint (e.g. deployable details, required resources, routing filters) and is typically provided by the CI tool as a template to the Vamp API. Vamp will then run, canary-release, monitor and scale the deployment based on the filters and conditions specified in the blueprint.&lt;/p&gt;

&lt;h2 id=&#34;vamp-compared-to-feature-toggle-frameworks&#34;&gt;Vamp compared to feature toggle frameworks&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;LaunchDarkly, Togglz, Petri&lt;/em&gt;&lt;br /&gt;
Feature toggle frameworks use code level feature toggles to conditionally test new functionality in an application or service. Tools such as LaunchDarkly and Togglz work with these toggles to enable, for example, A/B testing and canary functionality. While there are many cases for using feature toggles, there are also times when feature toggling isn&amp;rsquo;t the smartest choice.
Vamp allows controlled testing of new features without the need to adjust your code. To achieve this, Vamp controls traffic routing towards and between your applications and services based on blueprint descriptions of individual (micro)services and their dependencies. This makes sense on an application code level, offering increased security and reduced technical debt compared to maintaining toggles in your code, and provides a mature alternative for cases when feature toggles are not the appropriate choice.&lt;/p&gt;

&lt;h2 id=&#34;vamp-compared-to-configuration-management-and-provisioning-tools&#34;&gt;Vamp compared to configuration management and provisioning tools&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Puppet, Ansible, Chef, Terraform&lt;/em&gt;&lt;br /&gt;
The responsbilities of configuration management and infrastructure provisioning tools are often stretched to cover container deployment features. These tools were not intended for handling container deployments or for the dynamic management and routing traffic over these containers. Vamp has been designed and developed from the ground up specifically to fit these use cases.&lt;/p&gt;

&lt;h2 id=&#34;vamp-compared-to-custom-built-solutions&#34;&gt;Vamp compared to custom built solutions&lt;/h2&gt;

&lt;p&gt;Building and maintaining a scalable and robust enterprise-grade system for canary-testing and releasing is not trivial. Vamp delivers programmable routing and automatic load balancing, deployment orchestration and workflows, as well as a powerful event system, REST API, graphical UI, integration testing tools and a CLI.&lt;/p&gt;

&lt;h2 id=&#34;vamp-compared-to-a-b-and-mvt-testing-tools&#34;&gt;Vamp compared to A/B and MVT testing tools&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Optimizely, VisualWebsiteOptimizer, Google Analytics, Planout&lt;/em&gt;&lt;br /&gt;
Vamp enables canary testing versions of applications, effectively providing A/B and MVT testing of applications and services by deploying two or more versions of an application or service and dividing incoming traffic between the running versions. Vamp doesn&amp;rsquo;t have a built-in analytics engine though, so the analysing of the relevant metrics needs to be done with a specific Vamp workflow or an external analytics engine. Results can be fed back to Vamp to automatically update routing rules and deployments to push a winning version to a full production release. Because of the flexible programmable routing and use of environment variables, Vamp can be used to canary test almost everything, from content and business logic to configuration settings and architectural changes.&lt;/p&gt;

&lt;h2 id=&#34;vamp-compared-to-devops-tools&#34;&gt;Vamp compared to DevOps tools&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Deis, Flynn, Dokku&lt;/em&gt;&lt;br /&gt;
Vamp has no ambition to provide a Heroku-like environment for containers. Vamp integrates programmable routing and load balancing, container deployments and orchestration to enable canary testing and canary releasing features. Vamp also adds metrics-driven workflows for auto-scaling and other optimisations. Vamp sees business as a first class citizen in DevOps teams, providing a graphical UI and tools for non-technical roles.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/installation/hello-world&#34;&gt;Try Vamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./why-use-vamp/use-cases/&#34;&gt;Use cases&lt;/a&gt; -  some Vamp solutions to practical problems&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Get started</title>
      <link>/why-use-vamp/get-started/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/get-started/</guid>
      <description>

&lt;h2 id=&#34;try-vamp&#34;&gt;Try Vamp&lt;/h2&gt;

&lt;p&gt;To make the most of your &amp;lsquo;my first Vamp&amp;rsquo; experience, we suggest you start by installing our single, all-in-one &lt;a href=&#34;documentation/installation/hello-world/&#34;&gt;Vamp Docker Hello World package&lt;/a&gt;. This will set up everything you need to play around with Vamp on a local or remote dev machine - the container package includes Mesos/Marathon and Elastic Stack (ELK), as well as all the necessary Vamp components. We have some nice &lt;a href=&#34;documentation/tutorials&#34;&gt;tutorials&lt;/a&gt; to get a feel for the supernatural powers of Vamp.&lt;/p&gt;

&lt;h2 id=&#34;install-a-production-grade-vamp-setup&#34;&gt;Install a production-grade Vamp setup&lt;/h2&gt;

&lt;p&gt;Of course our Hello World package is no production-grade setup. We suggest your next step should be to understand the &lt;a href=&#34;documentation/how-vamp-works/architecture-and-components&#34;&gt;Vamp architecture&lt;/a&gt; and then find the Vamp version for your favorite container scheduler. We support most common container schedulers, so you should be able to find one to your liking in our &lt;a href=&#34;documentation/installation/&#34;&gt;installation docs&lt;/a&gt;. If you&amp;rsquo;re still not sure which container scheduler to work with, our &lt;a href=&#34;documentation/how-vamp-works/which-container-scheduler/&#34;&gt;&amp;lsquo;what to choose&amp;rsquo; guide&lt;/a&gt; can help you make an informed decision.&lt;/p&gt;

&lt;h2 id=&#34;fine-tune-and-integrate&#34;&gt;Fine tune and integrate&lt;/h2&gt;

&lt;p&gt;After you&amp;rsquo;ve successfully installed a production-grade Vamp on your preferred container-cluster manager/scheduler (if you need help here, find us in our &lt;a href=&#34;https://gitter.im/magneticio/vamp&#34;&gt;public Gitter channel&lt;/a&gt;), it&amp;rsquo;s time to either dive into the ways you can &lt;a href=&#34;documentation/using-vamp/artifacts/&#34;&gt;use Vamp&lt;/a&gt; or investigate how you can &lt;a href=&#34;documentation/installation/configure-vamp&#34;&gt;configure and fine-tune Vamp&lt;/a&gt; to match your specific requirements. It might also be interesting to integrate Vamp into your CI pipeline to create a CD pipeline with Vamp&amp;rsquo;s canary-releasing features. You can check out our &lt;a href=&#34;documentation/cli/cli-reference/&#34;&gt;CLI&lt;/a&gt; and &lt;a href=&#34;documentation/api/api-reference/&#34;&gt;REST API&lt;/a&gt; documentation for integrations.&lt;/p&gt;

&lt;h2 id=&#34;get-your-teeth-into-the-fun-stuff&#34;&gt;Get your teeth into the fun stuff!&lt;/h2&gt;

&lt;p&gt;At this point you&amp;rsquo;ve become a real Vamp guru. The next step could be to start playing around with our &lt;a href=&#34;https://github.com/magneticio/vamp-runner/&#34;&gt;Vamp Runner tool&lt;/a&gt; to investigate typical recipes, such as automated canary-releasing, auto-scaling and more. You can use the JavaScript-based workflows in the recipes as a reference to create your own recipes and workflows. Once you&amp;rsquo;ve created some cool workflows and recipes we would of course like to hear from you!&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Try the &lt;a href=&#34;documentation/installation/hello-world/&#34;&gt;Vamp Docker Hello World package&lt;/a&gt; and &lt;a href=&#34;documentation/tutorials&#34;&gt;tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Read about the &lt;a href=&#34;documentation/how-vamp-works/architecture-and-components&#34;&gt;Vamp architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Check the &lt;a href=&#34;documentation/installation/&#34;&gt;installation docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Move from monoliths and VM&#39;s to microservices</title>
      <link>/why-use-vamp/use-cases/refactor-monolithic-to-microsystems/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/refactor-monolithic-to-microsystems/</guid>
      <description>&lt;p&gt;&lt;em&gt;“We want to move to microservices, but we can’t upgrade all components at once and want to do a gradual migration”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Refactoring a monolithic application to a microservice architecture is a major project. A big bang style re-write to upgrade all components at once is a risky approach and requires a large investment in development, testing and refactoring.&lt;/p&gt;

&lt;p&gt;Why not work incrementally? Using Vamp&amp;rsquo;s routing you could introduce new services for specific application tiers like the frontend or business logic layers, and move traffic with specific conditions to these new services. These services in turn can connect to your legacy systems again, using Vamp&amp;rsquo;s proxying. A typical example would be introducing an angular based frontend or node.js based API microservice. You can send 2% of your incoming traffic to this new microservice frontend, which in turn connects with the legacy backend system. This way you can test your new microservices in a small and controlled way and avoid a big bang release. You can introduce new services one by one, test them in production and increase traffic until you migrated your entire application from a monolith to microservices.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Start small:&lt;/strong&gt; You can build e.g. one new frontend component. Vamp will deploy this to run alongside the legacy monolithic system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Activate smart routing:&lt;/strong&gt; Vamp can route traffic behind the scenes, so a small percentage of visitors is sent to the new frontend service, while the new frontend is routed by Vamp to the legacy backend. You can continue transferring components from the legacy monolithic system to new microservices and Vamp can adapt the routing as you go.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remove legacy components:&lt;/strong&gt; Once all services have been transferred from the legacy monolith, you can start removing components from the legacy system.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about using Vamp to &lt;a href=&#34;./why-use-vamp/use-cases/modernise-architecture/&#34;&gt;test and modernise architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>PaaS and container systems</title>
      <link>/why-use-vamp/vamp-compared-to/paas-and-container-systems/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/vamp-compared-to/paas-and-container-systems/</guid>
      <description>

&lt;h2 id=&#34;vamp-compared-to-container-schedulers-and-container-clouds-cpaas&#34;&gt;Vamp compared to container schedulers and container clouds (CPaaS)&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Docker Swarm, DC/OS, Mesos/Marathon, Kubernetes, Nomad, Rancher, AWS ECS, Azure CS, Mantl, Apollo&lt;/em&gt;&lt;br /&gt;
Container cluster managers and schedulers like Marathon, DC/OS, Kubernetes, Nomad or Docker Swarm provide great features to run containers in clustered setups. What they don&amp;rsquo;t provide are features to manage the lifecycle of a microservices or container based system. How to do continuous delivery, how to gradually introduce and upgrade versions in a controlled and risk-free way, how to aggregate metrics and how to use these metrics to optimise and scale your running system. Vamp adds these features on top of well-used container schedulers by dynamically managing routing and load balancing, deployment automation and metric driven workflows. Vamp also adds handy features like dependencies, ordering of deployments and resource management.&lt;/p&gt;

&lt;h2 id=&#34;vamp-compared-to-paas-systems&#34;&gt;Vamp compared to PaaS systems&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Cloud foundry, OpenStack, IBM Bluemix, Openshift&lt;/em&gt;&lt;br /&gt;
Vamp adds an experimentation layer to PaaS infrastructures by providing canary-releasing features that integrate with common PaaS proxies like HAProxy. For continuous delivery and auto-scaling features, Vamp integrates with common container-schedulers included in PaaS systems, like Kubernetes in Openshift V3.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about &lt;a href=&#34;./why-use-vamp/vamp-compared-to/frameworks-and-tools&#34;&gt;Vamp compared to common frameworks and tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/installation/hello-world&#34;&gt;Try Vamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Proxies and load balancers</title>
      <link>/why-use-vamp/vamp-compared-to/proxies-and-load-balancers/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/vamp-compared-to/proxies-and-load-balancers/</guid>
      <description>

&lt;h2 id=&#34;vamp-compared-to-software-based-proxies-and-load-balancers&#34;&gt;Vamp compared to software based proxies and load balancers&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;HAProxy, NGINX, linkerd, Traefik&lt;/em&gt;&lt;br /&gt;
Vamp adds programmable routing (percentage and condition based) and load balancing to the battle-tested HAProxy proxy, as well as a REST API, graphical UI and CLI.  This means you can use Vamp together with all common container-schedulers to provide continuous delivery and auto-scaling features using automatic load balancing and clustering of scaled out container instances. By default Vamp is packaged with HAProxy, but you could also integrate the Vamp magic with other programmable proxies such as NGINX, linkerd or Traefik.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about &lt;a href=&#34;./why-use-vamp/vamp-compared-to/paas-and-container-systems/&#34;&gt;Vamp compared to PaaS and container systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/installation/hello-world&#34;&gt;Try Vamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Resolve client-side incompatibilities after an upgrade</title>
      <link>/why-use-vamp/use-cases/resolve-incompatibilities-after-upgrade/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/resolve-incompatibilities-after-upgrade/</guid>
      <description>&lt;p&gt;&lt;em&gt;“We upgraded our website self-management portal, but our biggest client is running an unsupported old browser version”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Leaving an important client unable to access your services after a major upgrade is a big and potentially costly problem. The traditional response would be to rollback the upgrade asap - if that&amp;rsquo;s even possible.&lt;/p&gt;

&lt;p&gt;Why rollback? Using Vamp&amp;rsquo;s smart conditional routing you could send specific clients or browser-versions to an older version of your portal while others can enjoy the benefits of your new upgraded portal. Because Vamp supports SLA based autoscaling for (Docker) containers, you can deploy the old version on the same infrastructure as the new version is running on. This also avoids having to provision costly over dimensioned DTAP environments for only a small user-base, leveraging your existing infrastructure efficiently.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Re-deploy:&lt;/strong&gt; Vamp can (re)deploy a (containerised) compatible version of your portal to run side-by-side with the upgraded version.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Activate smart routing:&lt;/strong&gt; Vamp can route all users with e.g. a specific IP, browser or location to a compatible version of the portal. Other clients will continue to see the new upgraded portal.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resolve the incompatibility:&lt;/strong&gt; Once the client upgrades to a compatible browser Vamp can automatically route them to the new portal version.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about using Vamp to &lt;a href=&#34;./why-use-vamp/use-cases/refactor-monolithic-to-microsystems/&#34;&gt;move from monoliths and VMs to microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>See Vamp in action</title>
      <link>/why-use-vamp/see-vamp-in-action/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/see-vamp-in-action/</guid>
      <description>&lt;p&gt;Watch this video of running Vamp on &lt;a href=&#34;./documentation/installation/dcos/&#34;&gt;DC/OS&lt;/a&gt; an doing a &lt;a href=&#34;./documentation/tutorials/run-a-canary-release/&#34;&gt;canary release&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Vamp UI and DC/OS versions in this video are a little older than currently available. We will upload a new recording shortly.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/tlzfD1Uo9pk&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Self-healing and self-optimising</title>
      <link>/why-use-vamp/use-cases/self-healing-and-self-optimising/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/self-healing-and-self-optimising/</guid>
      <description>&lt;p&gt;&lt;em&gt;&amp;ldquo;Our website traffic can be unpredictable, it&amp;rsquo;s hard to plan and dimension the exact resources we&amp;rsquo;re going to need to run within SLA&amp;rsquo;s&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Why overdimension your whole system? Using Vamp you can auto-scale individual services based on clearly defined SLAs (Service Level Agreements). It&amp;rsquo;s also easy to create advanced workflows for up and down scaling, based on your application or business specific requirements. Vamp can also make sure that unhealthy and failing services are corrected based on clearly defined metrics and treshholds.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Set SLAs:&lt;/strong&gt; You can define SLA metrics, tresholds and escalation workflows. You can do this in Vamp YAML blueprints, modify our packaged workflows, or create your own workflow scripts for advanced use-cases.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimise:&lt;/strong&gt; Vamp workflows can automatically optimise your running system based on metrics that are relevant to your application or services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sleep easy:&lt;/strong&gt; Vamp will track troughs and spikes in activity and automatically scale services up and down to match your SLAs. All scaling events will be logged. Unhealthy services can be healed by Vamp.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about using Vamp for &lt;a href=&#34;./why-use-vamp/use-cases/service-discovery/&#34;&gt;service discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Service discovery</title>
      <link>/why-use-vamp/use-cases/service-discovery/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/service-discovery/</guid>
      <description>

&lt;p&gt;Vamp uses a service discovery pattern called server-side service discovery. This pattern allows service discovery without the need to change your code or run any other service-discovery daemon or agent. In addition to service discovery, Vamp also functions as a service registry. We recognise the following benefits of this pattern:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No code injection needed&lt;/li&gt;
&lt;li&gt;No extra libraries or agents needed&lt;/li&gt;
&lt;li&gt;Platform/language agnostic: it’s just HTTP&lt;/li&gt;
&lt;li&gt;Easy integration using ENV variables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vamp doesn&amp;rsquo;t need point-to-point wiring. Vamp uses environment variables that resolve to service endpoints Vamp automatically sets up and exposes. Even though Vamp provides this type of service discovery, it does not put any constraint on other possible solutions. For instance services can use their own approach specific approach using service registry, self-registration etc. Vamp can also integrate with common service discovery solutions like Consul and read from these to setup the required routing automatically.&lt;/p&gt;

&lt;h2 id=&#34;smartstack&#34;&gt;SmartStack&lt;/h2&gt;

&lt;p&gt;Vamp can automatically deploy a VampGatewayAgent(VGA)+HAProxy on every node of your container cluster. This creates a so-called &lt;em&gt;Layer 7 intra service network mesh&lt;/em&gt; which enables you to create a &amp;ldquo;SmartStack&amp;rdquo;, an automated service discovery and registration framework originally coined and developed by AirBnB. More on the history and advantages of the SmartStack approach can be read here (&lt;a href=&#34;http://nerds.airbnb.com/smartstack-service-discovery-cloud/&#34;&gt;nerds.airbnb.com - SmartStack: Service Discovery in the Cloud&lt;/a&gt;).&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read more about &lt;a href=&#34;./documentation/how-vamp-works/service-discovery&#34;&gt;Vamp service discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Simulate and test scaling behaviour</title>
      <link>/why-use-vamp/use-cases/simulate-and-test-scaling-behaviour/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/simulate-and-test-scaling-behaviour/</guid>
      <description>&lt;p&gt;&lt;em&gt;&amp;ldquo;How would our system react if&amp;hellip; the number of users increased x10 &amp;hellip; the response time of a service increased with 20 seconds &amp;hellip; an entire tier of our application would be killed &amp;hellip;&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Your company might dream of overnight success, but what if it actually happened? Stress tests rarely cater to extreme real world circumstances and usage patterns, and are often done on systems that are not identical to production environments. It&amp;rsquo;s not uncommon the bottleneck sits in the system generating the load itself, so it&amp;rsquo;s difficult to predict how your microservices would actually scale or to know if your planned responses will really help.&lt;/p&gt;

&lt;p&gt;Why not find out for sure? Using Vamp you can test your services and applications against difficult to predict or simulate situations, mocking all kinds of metrics, and then validate and optimise the workflows that handle the responses, like for example auto up and down scaling. With the same workflows as would be running in production, on the same infrastructure, with the same settings.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Mock required load:&lt;/strong&gt; Vamp can simulate (mock) high-stress situations for any kind of metric your system needs to respond to, without actually having to generate real traffic.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimise:&lt;/strong&gt; You can optimise your resource allocation and autoscaling configurations based on real validated behaviour under stress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Iterate until you&amp;rsquo;re certain:&lt;/strong&gt; Vamp can repeat the tests until you&amp;rsquo;re confident with the outcome. Then you can use the same scaling and optimising workflows in production.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about using Vamp for &lt;a href=&#34;./why-use-vamp/use-cases/self-healing-and-self-optimising/&#34;&gt;self healing and self optimising&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Test and modernise architecture</title>
      <link>/why-use-vamp/use-cases/modernise-architecture/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/use-cases/modernise-architecture/</guid>
      <description>&lt;p&gt;&lt;em&gt;&amp;ldquo;We want to switch to a NoSQL database for our microservices, but don&amp;rsquo;t know which solution will run best for our purposes&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With multiple NoSQL database options available, it&amp;rsquo;s hard to know which is the best fit for your specific circumstances. You can try things out in a test lab, but the real test comes when you go live with production load.&lt;/p&gt;

&lt;p&gt;Why guess? Using Vamp you could A/B test different versions of your services with different NoSQL backends, in production, and then use real data to make an informed and data-driven decision.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Deploy two versions:&lt;/strong&gt; Vamp can deploy multiple versions of your architecture, each with a different database solution (or other configuration settings), then distribute incoming traffic across each.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stress test:&lt;/strong&gt; Use the metrics reported by Vamp to measure which option performs best in production.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Keep the best performing option:&lt;/strong&gt; Once you have made your decision, Vamp can route all traffic to your chosen architecture. Services from the alternative options will be drained to ensure customer experience is not impacted by the test.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;Read about using Vamp to &lt;a href=&#34;./why-use-vamp/use-cases/simulate-and-test-scaling-behaviour/&#34;&gt;simulate and test scaling behaviour&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See &lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;how Vamp measures up&lt;/a&gt; to common platforms, tools and frameworks&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find out &lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;how Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Vamp Enterprise Edition</title>
      <link>/why-use-vamp/enterprise-edition/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/enterprise-edition/</guid>
      <description>&lt;p&gt;For features, pricing and availability of our commercial &lt;em&gt;Vamp Enterprise Edition (EE)&lt;/em&gt;, please contact &lt;a href=&#34;mailto:info@magnetic.io&#34;&gt;info@magnetic.io&lt;/a&gt; or call +31(0)88 555 33 99&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why use Vamp?</title>
      <link>/why-use-vamp/</link>
      <pubDate>Tue, 13 Sep 2016 09:00:00 +0000</pubDate>
      
      <guid>/why-use-vamp/</guid>
      <description>

&lt;p&gt;We recognise the pain and risk involved with delivering microservice applications.  We&amp;rsquo;ve been there too - facing downtime and unexpected issues while transitioning from one release to the next.
In microservice architectures, these concerns can quickly multiply. It&amp;rsquo;s all too easy to get stuck dealing with the added complexities and miss out on the potential benefits.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./images/typical-systems-vs-vamp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;what-is-vamp&#34;&gt;What is Vamp?&lt;/h2&gt;

&lt;p&gt;Vamp is an open source, self-hosted platform for managing (micro)service oriented architectures that rely on container technology. Vamp provides a DSL to describe services, their dependencies and required runtime environments in blueprints and a runtime/execution engine to deploy these blueprints (similar to AWS Cloudformation). Planned deployments and running services can be managed from your choice of Vamp interface - graphical UI, command line interface or RESTful API.&lt;/p&gt;

&lt;p&gt;Vamp takes care of route updates, metrics collection and service discovery, so you can easily orchestrate complex deployment patterns, such as architecture level A/B testing and canary releases.
After deployment, Vamp workflows monitor running applications and can act automatically based on defined SLAs.&lt;/p&gt;

&lt;h3 id=&#34;vamp-facts&#34;&gt;Vamp facts&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Vamp is platform agnostic&lt;/li&gt;
&lt;li&gt;Vamp is functionality agnostic, but functions well in an API centric, event driven and stateless environment.&lt;/li&gt;
&lt;li&gt;Vamp is not a strict container platform, but uses the power of container platforms under the hood.&lt;/li&gt;
&lt;li&gt;Vamp is written in Scala, Go and ReactJS&lt;/li&gt;
&lt;li&gt;Vamp includes clear SLA management and service level enforcement out of the box&lt;/li&gt;
&lt;li&gt;Vamp is an open source project, actively developed by &lt;a href=&#34;./about/&#34;&gt;Magnetic.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
  &lt;p class=&#34;admonition-title&#34;&gt;What next?&lt;/p&gt;
  &lt;p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/installation/hello-world&#34;&gt;Try Vamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Read the full &lt;a href=&#34;./why-use-vamp/feature-list/&#34;&gt;Vamp feature list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./why-use-vamp/vamp-compared-to/proxies-and-load-balancers/&#34;&gt;What Vamp offers compared to other tools and services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./documentation/how-vamp-works/architecture-and-components&#34;&gt;How Vamp works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>